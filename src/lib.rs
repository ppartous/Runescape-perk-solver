//! # Perk generation
//! Perks are generated in a fairly complex manner.
//!
//! In the following code, `random(x, y)` generates an integer between x and y-1, inclusive of both. `floor(x)` rounds
//! down x to the nearest integer.
//!
//! First, some background data. Each material has a selection of perks it can give, and each of those perks have two
//! associated numbers - a fixed part (`base`) and a random part (`roll`). These numbers differ between materials for the
//! same perks. For example: for the [Precise](https://runescape.wiki/w/Precise) perk,
//! [Precise components](https://runescape.wiki/w/Precise_components) have a base of 9 and a roll of 32;
//! [Armadyl components](https://runescape.wiki/w/Armadyl_components) have a base of 44 and a roll of 8.
//!
//! Ancient components are exclusive to [ancient gizmos](https://runescape.wiki/w/Ancient_gizmo) and cannot be used in
//! normal gizmo shells (these have the value of `ancient_only` set to `true` in our [data file](../data.json)). When we
//! use a material other than ancient components inside of an ancient gizmo, the aforementioned `base` and `roll` values for
//! that material's possible perks are multiplied by 80%.
//!
//! Additionally, each perk has a number of ranks, and each rank has two associated numbers - a rank threshold
//! (`threshold`), and a rank value (`cost`). For example, the Precise perk has thresholds 50, 80, 130, 170, 210, and values
//! 35, 65, 120, 160, 195, corresponding to each of the 5 ranks.
//!
//! 1. Generate the invent budget. This is calculated by summing 5 rolls of `random(0, floor(invention level / 2) + 20)`
//!    (that means 5 separate random rolls; includes boosts to Invention level). If using an ancient gizmo, an additional
//!    roll (a total of 6) is performed.
//!        - If invent budget is below your Invention level, set it to your Invention level.
//! 2. Calculate the perk values for each perk that can be generated by the input materials. Keep track of perks
//!    available in an array; add this to the array in order of the materials, iterating the slots in order middle, top,
//!    left, right, bottom (along with top-left, top-right, bottom-left, and bottom-right if using an ancient gizmo).
//!    This is done by calculating base + random(0, roll) for each material and each perk, summing the values if multiple
//!    materials use the same perk.
//! 3. Calculate the rank generated by finding the largest rank threshold that the corresponding perk value is greater
//!    than or equal to. If the perk value is less than the lowest rank threshold for a given perk, then set the rank to 0
//!    with a cost of 0. These perks cannot be generated, however must still be included at this point as it affects the
//!    operation of the following sorting algorithm.
//! 4. Sort the perks in ascending order of rank cost (lowest value first) using a modified quicksort algorithm (see below).
//! 5. For each perk in the sorted perk values, in reverse order:
//!        - If the current invent budget is less than or equal to the rank cost, move on to the next perk.
//!        - If invent budget is strictly greater than the rank cost, this perk-rank combination is generated. Subtract
//!          the rank cost from invent budget and continue to the next perk with the new invent budget.
//! 6. Once you have generated 2 perks, or ran out of perks to check, we are done.
//!        - If either one of the perks generated was a two-slot perk (Enhanced Devoted or Enhanced Efficient), set the
//!          second perk generated to nothing.
//!        - If you generated no perks, the gizmo shell and the materials are not consumed.
//!
//! ## Sorting
//!
//! Sorting of the perk array by `rank cost` is done by a modified [quicksort](https://en.wikipedia.org/wiki/Quicksort)
//! algorithm. How this sort breaks ties is extremely important and slight differences in the method can make massive
//! differences in what perks are generated. This is also why the array is sorted into ascending order then iterated
//! backwards, rather than sorted into descending order and iterated forwards.
//![rank.values.name as usize]
//! It is easier to provide an implementation of the sort than describe it - since it is mostly quicksort, you can see
//! the above linked wikipedia page for it. Here is a javascript implementation of the sort, as is used by the
//! [calculator on the wiki](https://runescape.wiki/w/Calculator:Perks).
//!
//! ```js
//!  /**
//!  * Sorts an array in-place
//!  * compare(x,y) should be a function that returns a positive number if x>y, a negative number if x<y, and 0 if x=y - the easiest way to do that is return x-y
//!  */
//! function quicksort(low, high, arr, compare) {
//!     var pivot_index = (~~((low + high)/2)); // floor division
//!     var pivot_value = arr[pivot_index];
//!     arr[pivot_index] = arr[high];
//!     arr[high] = pivot_value;
//!     var counter = low;
//!     var loop_index = low;
//!
//!     while (loop_index < high) {
//!         if (compare(arr[loop_index], pivot_value) < (loop_index & 1)) {
//!             var tmp = arr[loop_index];
//!             arr[loop_index] = arr[counter];
//!             arr[counter] = tmp;
//!             counter = counter + 1;
//!         }
//!         loop_index = loop_index + 1;
//!     }
//!
//!     arr[high] = arr[counter];
//!     arr[counter] = pivot_value;
//!
//!     if (low < (counter - 1)) {
//!         quicksort(low, counter - 1, arr, compare);
//!     }
//!     if ((counter + 1) < high) {
//!         quicksort(counter + 1, high, arr, compare);
//!     }
//! }
//! // example use
//! var perkArr = [
//!     {'perk': 'Cautious', 'cost': 0, 'probability': 0.0019369834710743802, 'rank': 0},
//!     {'perk': 'Blunted', 'cost': 0, 'probability': 0.00021947873799725651, 'rank': 0},
//!     {'perk': 'Equilibrium', 'cost': 0, 'probability': 0.11297548487631127, 'rank': 0},
//!     {'perk': 'Precise', 'cost': 65, 'probability': 0.00510406494140625, 'rank': 2},
//!     {'perk': 'Flanking', 'cost': 0, 'probability': 0.013885498046875, 'rank': 0}
//! ];
//! quicksort(0, (perkArr.length - 1), perkArr, function (x, y) { return x.cost - y.cost });
//! // sorts into order Blunted, Equilibrium, Flanking, Cautious, Precise
//! ```
//!
//! The most notable line is the comparison - `compare(arr[loop_index], pivot_value) < (loop_index & 1)`. In the game code,
//! the comparison alternates with loop_index between `< 0` and `<= 0`, which we emulate by the bitwise AND
//! (`loop_indexÂ % 2` has the same effect) to make the comparison `< 0` and `< 1`.

pub mod component_prices;
mod dice;
mod gizmo_cost_thresholds;
mod jagex_sort;
mod perk_values;
pub mod prelude;
pub mod result;
mod utils;

use colored::Colorize;
use component_prices::{load_component_prices, set_shell_price};
use gizmo_cost_thresholds::*;
use indicatif::{ProgressBar, ProgressStyle};
use itertools::Itertools;
use perk_values::*;
pub use prelude::*;
use smallvec::{smallvec, SmallVec};
use std::cmp::{self, Ord, PartialOrd};
use std::sync::atomic::{self, Ordering::Relaxed};
use std::sync::{mpsc, Arc};
use std::thread;
use std::time::Duration;
use threadpool::ThreadPool;

#[derive(Clone)]
pub struct SolverMetadata {
    pub materials: Arc<SplitMaterials>,
    pub bar_progress: Arc<atomic::AtomicU64>,
    pub total_combination_count: u64,
    pub args: Arc<Args>,
    pub cancel_signal: Arc<atomic::AtomicBool>,
}

pub struct Solver {
    wanted_gizmo: Gizmo,
    result_tx: Option<mpsc::SyncSender<Vec<ResultLine>>>,
    result_handler: thread::JoinHandle<Vec<Vec<ResultLine>>>,
    data: Arc<Data>,
    pub meta: SolverMetadata,
}

impl Solver {
    pub fn new(args: Args, data: Data) -> Result<Solver, String> {
        let args = Arc::new(args);
        let data = Arc::new(data);
        let wanted_gizmo = Gizmo {
            perks: (
                Perk {
                    name: args.perk,
                    rank: args.rank,
                },
                Perk {
                    name: args.perk_two,
                    rank: args.rank_two,
                },
            ),
            ..Default::default()
        };
        validate_input(&args, wanted_gizmo, &data)?;
        let materials = get_materials(&args, &data, wanted_gizmo)?;
        load_component_prices(&args.price_file, false)?;
        set_shell_price(args.gizmo_type, args.ancient);
        let materials = Arc::new(split_materials(&args, &data, wanted_gizmo, materials));
        let total_combination_count = calc_combination_count(
            materials.conflict.len(),
            materials.no_conflict.len(),
            args.ancient,
        );
        let bar_progress = Arc::new(atomic::AtomicU64::new(0));
        let (result_tx, result_rx) = mpsc::sync_channel::<Vec<ResultLine>>(1000);
        let result_handler = result::result_handler(args.clone(), result_rx);
        let cancel_signal = Arc::new(atomic::AtomicBool::new(false));

        Ok(Solver {
            wanted_gizmo,
            result_tx: Some(result_tx),
            result_handler,
            data,
            meta: SolverMetadata {
                materials,
                bar_progress,
                total_combination_count,
                args,
                cancel_signal,
            },
        })
    }

    pub fn run(mut self) -> Vec<Vec<ResultLine>> {
        let budgets = Arc::new(generate_budgets(
            &self.meta.args.invention_level,
            self.meta.args.ancient,
        ));
        let slot_count = if self.meta.args.ancient { 9 } else { 5 };
        let pool = if self.meta.args.limit_cpu {
            ThreadPool::new(num_cpus::get() * 8 / 10)
        } else {
            ThreadPool::new(num_cpus::get() * 2)
        };
        let ten_millis = Duration::from_millis(10);
        let materials = &self.meta.materials;
        let wanted_gizmo = self.wanted_gizmo;

        'cancel: for n_mats_used in 1..=slot_count {
            {
                let tx = self.result_tx.as_ref().unwrap().clone();
                let data = self.data.clone();
                let args = self.meta.args.clone();
                let budgets = budgets.clone();
                let bar_progress = self.meta.bar_progress.clone();
                let materials = self.meta.materials.clone();
                let cancel_signal = self.meta.cancel_signal.clone();
                pool.execute(move || {
                    // Order does no matter when none of the materials used have a cost conflict with the wanted perks
                    for mat_combination in materials
                        .no_conflict
                        .iter()
                        .copied()
                        .combinations_with_replacement(n_mats_used)
                    {
                        if cancel_signal.load(Relaxed) {
                            break;
                        }
                        let lines = calc_wanted_gizmo_probabilities(
                            &data,
                            &args,
                            &budgets,
                            mat_combination,
                            wanted_gizmo,
                            &mut None,
                        );
                        bar_progress.fetch_add(1, Relaxed);
                        if lines.len() > 0 {
                            tx.send(lines).ok();
                        }
                    }
                });
            }

            for n_conflict_mats in 1..=usize::min(n_mats_used, materials.conflict.len()) {
                for conflict_mats in materials
                    .conflict
                    .iter()
                    .copied()
                    .combinations(n_conflict_mats)
                {
                    for n_noconflict_mats in
                        0..=usize::min(n_mats_used - n_conflict_mats, materials.no_conflict.len())
                    {
                        for no_conflict_mats in materials
                            .no_conflict
                            .iter()
                            .copied()
                            .combinations(n_noconflict_mats)
                        {
                            let mut mats = no_conflict_mats;
                            mats.extend_from_slice(&conflict_mats);
                            let mats = Arc::new(mats);
                            for unordered_mats in
                                mats.iter().copied().combinations_with_replacement(
                                    n_mats_used - n_conflict_mats - n_noconflict_mats,
                                )
                            {
                                let tx = self.result_tx.as_ref().unwrap().clone();
                                let data = self.data.clone();
                                let args = self.meta.args.clone();
                                let budgets = budgets.clone();
                                let bar_progress = self.meta.bar_progress.clone();
                                let mats = mats.clone();
                                let cancel_signal = self.meta.cancel_signal.clone();
                                while pool.queued_count() > 100000 {
                                    std::thread::sleep(ten_millis);
                                }
                                if cancel_signal.load(Relaxed) {
                                    break 'cancel;
                                }
                                pool.execute(move || {
                                    let mut has_conflict = None;
                                    for ordered_mats in mats
                                        .iter()
                                        .copied()
                                        .permutations(n_conflict_mats + n_noconflict_mats)
                                    {
                                        if cancel_signal.load(Relaxed) {
                                            break;
                                        }
                                        if has_conflict.is_none() || (has_conflict.unwrap() == true)
                                        {
                                            let mut mat_combination = ordered_mats;
                                            mat_combination.extend_from_slice(&unordered_mats);
                                            let lines = calc_wanted_gizmo_probabilities(
                                                &data,
                                                &args,
                                                &budgets,
                                                mat_combination,
                                                wanted_gizmo,
                                                &mut has_conflict,
                                            );
                                            if lines.len() > 0 {
                                                tx.send(lines).ok();
                                            }
                                        }
                                        bar_progress.fetch_add(1, Relaxed);
                                    }
                                });
                            }
                        }
                    }
                }
            }
        }

        pool.join();

        self.result_tx.take();
        self.result_handler.join().unwrap()
    }
}

pub fn perk_solver(args: Args) {
    let data = Data::load();
    let solver = Solver::new(args, data).unwrap_or_else(|err| utils::print_error(err.as_str()));
    let meta = solver.meta.clone();
    println!("{}\n", meta.args.as_ref());
    println!("{}\n", meta.materials);

    // let x = setupData.bar_progress.clone();
    let bar_handler = thread::spawn(move || {
        let bar = ProgressBar::new(meta.total_combination_count);
        bar.set_style(
            ProgressStyle::with_template(
                "[{elapsed_precise}] {bar:60} {human_pos}/{human_len} ({percent}%)",
            )
            .unwrap(),
        );
        let interval = Duration::from_millis(100);

        loop {
            std::thread::sleep(interval);
            bar.set_position(meta.bar_progress.load(Relaxed));
            if meta.bar_progress.load(Relaxed) == meta.total_combination_count {
                bar.finish();
                break;
            }
        }
    });

    let best_per_level = solver.run();

    bar_handler.join().ok();
    println!("\n");

    result::print_result(&best_per_level, &meta.args);
    result::write_best_mats_to_file(&best_per_level, &meta.args);
}

/// Returns a vector of all possible gizmos and their probabilities
pub fn calc_gizmo_probabilities(
    data: &Data,
    budget: &Budget,
    input_materials: &Vec<MaterialName>,
    gizmo_type: GizmoType,
    is_ancient: bool,
) -> Vec<Gizmo> {
    let perk_values = get_perk_values(data, input_materials, gizmo_type, is_ancient);
    let perk_values = calc_perk_rank_probabilities(data, &perk_values, is_ancient);
    let mut permutations = permutate_perk_ranks(&perk_values, None);

    for x in permutations.iter_mut() {
        jagex_sort::jagex_quicksort(x);
    }

    let mut gizmo_arr: Vec<Gizmo> = vec![];
    for comb in permutations {
        let mut cost_thresholds = find_gizmo_cost_thresholds(&comb, budget.range.max);
        calc_probability_from_thresholds(&mut cost_thresholds, budget, comb.probability);

        for gizmo in cost_thresholds {
            if gizmo.probability == 0.0 {
                continue;
            }

            if let Some(x) = gizmo_arr.iter_mut().find(|x| **x == gizmo) {
                x.probability += gizmo.probability;
            } else {
                gizmo_arr.push(gizmo);
            }
        }
    }

    gizmo_arr.sort_by(|x, y| f64::partial_cmp(&y.probability, &x.probability).unwrap());
    gizmo_arr
}

fn validate_input(args: &Args, wanted_gizmo: Gizmo, data: &Data) -> Result<(), String> {
    if wanted_gizmo.perks.0.name == PerkName::Empty {
        return Err("First perk can't be empty.".to_string());
    }

    if data.perks[wanted_gizmo.perks.0.name].doubleslot
        && wanted_gizmo.perks.1.name != PerkName::Empty
    {
        return Err(format!(
            "Perk '{}' can't be combined with another perk as it uses both slots.",
            wanted_gizmo.perks.0.name.to_string().yellow()
        ));
    }
    if data.perks[wanted_gizmo.perks.1.name].doubleslot {
        return Err(format!(
            "Perk '{}' can't be combined with another perk as it uses both slots.",
            wanted_gizmo.perks.1.name.to_string().yellow()
        ));
    }

    if wanted_gizmo.perks.0.rank as usize >= data.perks[wanted_gizmo.perks.0.name].ranks.len() {
        return Err(format!(
            "Perk '{}' only goes up to rank {}.",
            wanted_gizmo.perks.0.name.to_string().yellow(),
            (data.perks[wanted_gizmo.perks.0.name].ranks.len() - 1)
                .to_string()
                .yellow()
        ));
    }

    if wanted_gizmo.perks.1.name != PerkName::Empty
        && wanted_gizmo.perks.1.rank as usize >= data.perks[wanted_gizmo.perks.1.name].ranks.len()
    {
        return Err(format!(
            "Perk '{}' only goes up to rank {}.",
            wanted_gizmo.perks.1.name.to_string().yellow(),
            (data.perks[wanted_gizmo.perks.1.name].ranks.len() - 1)
                .to_string()
                .yellow()
        ));
    }

    if wanted_gizmo.perks.0.rank == 0 {
        return Err(format!(
            "Perk '{}' must have a rank greater than zero.",
            wanted_gizmo.perks.0.name.to_string().yellow()
        ));
    }

    if wanted_gizmo.perks.1.name != PerkName::Empty && wanted_gizmo.perks.1.rank == 0 {
        return Err(format!(
            "Perk '{}' must have a rank greater than zero.",
            wanted_gizmo.perks.1.name.to_string().yellow()
        ));
    }

    match args.invention_level {
        InventionLevel::Single(x) => {
            match x {
                1..=137 => (),
                _ => return Err("Invention level must be between 1 and 137.".to_string())
            }
        },
        InventionLevel::Range(x, y) => {
            match (x, y) {
                (x, y) if x > y => return Err("First value of the invention level range must be lower or equal to the second value.".to_string()),
                (1..=137, 1..=137) => (),
                _ => return Err("Invention level must be between 1 and 137.".to_string())
            }
        }
    }

    Ok(())
}

fn calc_wanted_gizmo_probabilities(
    data: &Data,
    args: &Args,
    budgets: &Vec<Budget>,
    input_materials: Vec<MaterialName>,
    wanted_gizmo: Gizmo,
    has_conflict: &mut Option<bool>,
) -> Vec<ResultLine> {
    let perk_values = get_perk_values(data, &input_materials, args.gizmo_type, args.ancient);

    if !can_generate_wanted_ranks(data, &perk_values, wanted_gizmo) {
        has_conflict.replace(false);
        return vec![];
    }

    let perk_values = calc_perk_rank_probabilities(data, &perk_values, args.ancient);
    if has_conflict.is_none() {
        has_conflict.replace(contains_conflict_ranks(data, &perk_values, wanted_gizmo));
    }
    let mut permutations = permutate_perk_ranks(&perk_values, Some(wanted_gizmo));

    for x in permutations.iter_mut() {
        jagex_sort::jagex_quicksort(x);
    }

    let mut p_wanted: SmallVec<[f64; 96]> = smallvec![0.0; budgets.len()];
    let p_empty: SmallVec<[f64; 96]> = budgets
        .iter()
        .map(|x| get_empty_gizmo_chance(x, &perk_values))
        .collect();
    for combination in permutations.iter() {
        let mut cost_thresholds = if args.fuzzy {
            fuzzy_find_wanted_gizmo_cost_thresholds(
                combination,
                budgets.last().unwrap().range.max,
                wanted_gizmo,
            )
        } else {
            find_wanted_gizmo_cost_thresholds(
                combination,
                budgets.last().unwrap().range.max,
                wanted_gizmo,
            )
        };

        for (budget, pw) in budgets.iter().zip(&mut p_wanted) {
            calc_probability_from_thresholds(&mut cost_thresholds, budget, combination.probability);
            for x in cost_thresholds.iter() {
                if (args.fuzzy && x.contains(&wanted_gizmo))
                    || (!args.fuzzy && x.same(&wanted_gizmo))
                {
                    *pw += x.probability;
                }
            }
        }
    }

    let input_materials = Arc::new(input_materials);
    itertools::multizip((budgets, p_wanted, p_empty))
        .filter(|(_, pw, _)| *pw > 0.0)
        .map(|(budget, pw, pe)| ResultLine::create(budget.level, pw, pe, input_materials.clone()))
        .collect()
}

fn calc_probability_from_thresholds(cth_in: &mut [Gizmo], budget: &Budget, comb_probability: f64) {
    let mut it = cth_in.iter_mut().peekable();
    while let Some(curr) = it.next() {
        // A gizmo is generated when the budget roll is strictly greater than the gizmo cost.
        // The budget arg of this function is a cumulative distribution of all possible budget roll values where the
        // index corresponds to that particular budget roll.
        // So if x is the cost of the current gizmo and y is the cost of the next one then the probability than the budget
        // roll is strictly greater than x but smaller or equal to y is budget[y] - budget[x]
        let mut curr_threshold = curr.cost;
        let mut next_threshold = if let Some(next) = it.peek() {
            i16::min(next.cost, budget.range.max as i16)
        } else {
            budget.range.max as i16
        };
        let mut prob = 0.0;

        // The prob is always 0 if both costs are equal to each other or if both are lower than your invention level
        // because any budget roll under you invention level gets changed to a value equal to the invention level so the
        // probability to roll a value lower than that is zero
        if next_threshold > curr_threshold && next_threshold >= (budget.range.min as i16) {
            if curr_threshold < (budget.range.min as i16) {
                prob = budget.dist[next_threshold as usize];
            } else {
                // If we are in the upper half of the probability distribution, mirror around the center to prevent loss of accuracy
                // because on the upper half the values are close to 1 but we are only interested in the difference of two values.
                // The distribution is point symmetric around the halfway point
                let midpoint = budget.range.max as i16 / 2;
                if curr_threshold > midpoint {
                    let tmp = next_threshold;
                    next_threshold = budget.range.max as i16 - curr_threshold - 1;
                    curr_threshold = budget.range.max as i16 - tmp - 1;
                }

                if curr_threshold == -1 {
                    prob = budget.dist[next_threshold as usize];
                } else {
                    prob =
                        budget.dist[next_threshold as usize] - budget.dist[curr_threshold as usize];
                }
            }
        }

        curr.probability = prob * comb_probability;
    }
}

fn get_materials(
    args: &Args,
    data: &Data,
    wanted_gizmo: Gizmo,
) -> Result<Vec<MaterialName>, String> {
    let get_mats = |perk| {
        let mut possible_materials = Vec::new();

        for (mat_name, mat_data) in data.comps.iter() {
            for comp_values in mat_data[args.gizmo_type].iter() {
                if (comp_values.perk == perk) && (args.ancient || !mat_data.ancient_only) {
                    possible_materials.push(mat_name);
                }
            }
        }

        possible_materials
    };

    let perk_one_mats = get_mats(wanted_gizmo.perks.0.name);
    let perk_two_mats = get_mats(wanted_gizmo.perks.1.name);

    if perk_one_mats.is_empty() {
        return Err(format!(
            "No materials found that can produce {}. Is the gizmo type correct?",
            wanted_gizmo.perks.0.name.to_string().yellow()
        ));
    }
    if !wanted_gizmo.perks.1.is_empty() && perk_two_mats.is_empty() {
        return Err(format!(
            "No materials found that can produce {}. Is the gizmo type correct?",
            wanted_gizmo.perks.1.name.to_string().yellow()
        ));
    }

    let possible_materials = perk_one_mats
        .into_iter()
        .chain(perk_two_mats)
        .unique()
        .sorted()
        .filter(|x| !args.exclude.iter().contains(x))
        .collect_vec();

    if possible_materials.is_empty() {
        return Err("No materials left after filtering.".to_string());
    }

    Ok(possible_materials)
}

/// Splits material into two groups: conflict and non-conflict materials.
///
/// Conflict materials are materials that can generate perks with an equal cost value as one of the wanted perk ranks.
/// This matters as equal cost values can cause unstable sorting results so for these material combinations the order
/// of the materials if important whereas gizmos made entirely from non-conflict materials are position independent.
fn split_materials(
    args: &Args,
    data: &Data,
    wanted_gizmo: Gizmo,
    mats: Vec<MaterialName>,
) -> SplitMaterials {
    let mut conflict = Vec::new();
    let mut no_conflict = Vec::new();

    let cost_p1 =
        data.perks[wanted_gizmo.perks.0.name].ranks[wanted_gizmo.perks.0.rank as usize].cost;
    let cost_p2 = if wanted_gizmo.perks.1.name != PerkName::Empty {
        data.perks[wanted_gizmo.perks.1.name].ranks[wanted_gizmo.perks.1.rank as usize].cost
    } else {
        0
    };

    if cost_p1 == cost_p2 {
        return SplitMaterials {
            conflict: mats,
            no_conflict: vec![],
        };
    }

    for mat in mats {
        let mut is_conflict = false;
        'comp: for comp_values in data.comps[mat][args.gizmo_type].iter() {
            if comp_values.perk != wanted_gizmo.perks.0.name
                && comp_values.perk != wanted_gizmo.perks.1.name
            {
                for perk_rank in data.perks[comp_values.perk].ranks.iter() {
                    if perk_rank.rank > 0
                        && (perk_rank.cost == cost_p1 || perk_rank.cost == cost_p2)
                    {
                        conflict.push(mat);
                        is_conflict = true;
                        break 'comp;
                    }
                }
            }
        }

        if !is_conflict {
            no_conflict.push(mat);
        }
    }

    SplitMaterials {
        conflict,
        no_conflict,
    }
}

/// Each budget is a cumulative probability distribution for the invention level related random rolls.
fn generate_budgets(invention_level: &InventionLevel, ancient: bool) -> Vec<Budget> {
    let (low, high) = match invention_level {
        InventionLevel::Single(x) => (*x, *x),
        InventionLevel::Range(x, y) => (*x, *y),
    };
    let mut budgets = Vec::new();

    for lvl in (low..=high).step_by(2) {
        budgets.push(Budget::create(lvl as usize, ancient));
    }

    budgets
}

/// Calculate how many material combination there are so we can show a progress bar.
///
/// This calculation is made up of two parts because materials are split in conflict and no-conflict types. If a
/// combination of materials only contains no-conflict materials then the order of the materials doesn't matter. As
/// soon as the combination contains at least one conflict material then we can't be certain that order doesn't matter
/// so we have to check every order. But it's only the order of first occurrence that matters so the pattern abbc is the
/// same as abcb. The order of the repeated materials also doesn't matter so abcbc is the same as abccb.
fn calc_combination_count(conflict_size: usize, no_conflict_size: usize, is_ancient: bool) -> u64 {
    let slot_count = if is_ancient { 9 } else { 5 };
    let mut count = 0.0;

    for i in 1..=slot_count {
        count += dice::choose(no_conflict_size + i - 1, i); // Combination with repetition

        for j in 1..=cmp::min(i, conflict_size) {
            let mut x = 0.0;
            for k in 0..=cmp::min(i - j, no_conflict_size) {
                x += dice::choose(no_conflict_size, k)
                    * utils::fac(j + k)
                    * dice::choose(i - 1, i - j - k);
            }

            count += x * dice::choose(conflict_size, j);
        }
    }

    (count + 0.5) as u64
}

#[rustfmt::skip]
#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::{check_index, check_index_relative, check_len};
    use once_cell::sync::Lazy;

    static DATA: Lazy<Data> = Lazy::new(|| Data::load());

    mod calc_gizmo_probabilities_tests {
        use super::*;

        fn assert_gizmo_vec_eq(actual: &Vec<Gizmo>, expected: &Vec<Gizmo>) {
            check_len(actual, expected);

            for (i, (acc, exp)) in actual.iter().zip(expected).enumerate() {
                check_index(acc.perks.0.name, exp.perks.0.name, i, "perks.0.name", actual, expected);
                check_index(acc.perks.1.name, exp.perks.1.name, i, "perks.1.name", actual, expected);
                check_index(acc.perks.0.rank, exp.perks.0.rank, i, "perks.0.rank", actual, expected);
                check_index(acc.perks.1.rank, exp.perks.1.rank, i, "perks.1.rank", actual, expected);
                check_index_relative(acc.probability, exp.probability, 2.0, i, "probability", actual, expected);
            }
        }

        #[test]
        fn normal_weapon_120_1_precise() {
            let is_ancient = false;
            let gizmo_type = GizmoType::Weapon;
            let budget = Budget::create(120, is_ancient);
            let input_materials = vec![MaterialName::PreciseComponents];
            let expected = vec![
                Gizmo { perks: (Perk { name: PerkName::Empty, rank: 0 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.45208333333333300397, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.27447916666666644092, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.15069444444444446418, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.09444444444444442810, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.01458333333333332489, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00885416666666665950, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00486111111111111119, cost: 0 },
            ];
            let actual =
                calc_gizmo_probabilities(&*DATA, &budget, &input_materials, gizmo_type, is_ancient);
            assert_gizmo_vec_eq(&actual, &expected);
        }

        #[test]
        fn normal_weapon_120_2_precise() {
            let is_ancient = false;
            let gizmo_type = GizmoType::Weapon;
            let budget = Budget::create(120, is_ancient);
            let input_materials = vec![
                MaterialName::PreciseComponents,
                MaterialName::PreciseComponents,
            ];
            let expected = vec![
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.20546541543240931516, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Eruptive, rank: 1 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.18022017045454558071, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Eruptive, rank: 1 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.16929773588154284347, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.13304909628694361334, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.13262716469195331981, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.06153817202239465767, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.02723699019960137621, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Eruptive, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.01727003302455934475, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.01440171201963010711, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 2 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.01357231551147872889, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.01352927434178059427, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00472585361993050224, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00445369108223621097, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00443956732616146606, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00417533538959644762, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00416209436827637454, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Eruptive, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00264743569456500931, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Eruptive, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00263904002111501473, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00195119969298214327, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Empty, rank: 0 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00064027694205510022, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00060025963317665641, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00053940118677738176, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Eruptive, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00038060386306642847, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Eruptive, rank: 1 }), probability: 0.00036408115243342546, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00005502422262545732, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000843502098908373, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00000840827145106338, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000121264572358920, cost: 0 },
            ];
            let actual =
                calc_gizmo_probabilities(&*DATA, &budget, &input_materials, gizmo_type, is_ancient);
            assert_gizmo_vec_eq(&actual, &expected);
        }

        // #[test]
        // fn normal_weapon_120_3_precise() {
        //     let is_ancient = false;
        //     let gizmo_type = GizmoType::Weapon;
        //     let budget = Budget::create(120, is_ancient);
        //     let input_materials = vec![
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //     ];
        //     let expected = vec![
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.50148529240406880536, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.31900949274076889628, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.06318983947815995372, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.06181838816818274046, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.04076279645252363359, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00549081774031080685, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00238977097897312548, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00175485562231856803, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00130515980500081510, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00088957935848490868, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00061839010298976517, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00050921550166558303, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00032005993282243803, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00012263483799626810, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00011830768998579210, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00007801161480527289, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00006622963316091367, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00004863742383065568, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 2 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00001050829667738771, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 3 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00000335843300168647, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00000171293103489465, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000119802237126897, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00000118347156505853, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000115575036924211, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000076209714370380, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000064699871149279, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000038288582745159, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000036937577049252, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000024356489700309, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000020677964197583, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000014796753592088, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00000013492437968104, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00000013016359742176, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 4 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00000009308203320685, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00000008582935247028, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Blunted, rank: 1 }), probability: 0.00000007286666918426, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 3 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000004729016234232, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000002411981620020, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000001666448680412, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000001061202986255, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000001023758631407, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000000675062322800, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000000573108634033, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000000332435832882, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Blunted, rank: 4 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000000131068997336, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000000037900106652, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000000036562808265, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000000024109368671, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Empty, rank: 0 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000000004681035619, cost: 0 },
        //     ];
        //     let actual = calc_gizmo_probabilities(&*DATA, &budget, &input_materials, gizmo_type, is_ancient);
        //     assert_gizmo_vec_eq(&actual, &expected);
        // }

        // #[test]
        // fn ancient_weapon_137_9_precise() {
        //     let is_ancient = true;
        //     let gizmo_type = GizmoType::Weapon;
        //     let budget = Budget::create(137, is_ancient);
        //     let input_materials = vec![
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //         MaterialName::PreciseComponents,
        //     ];
        //     let expected = vec![
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Flanking, rank: 2 }), probability: 0.26431314143538087169, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Flanking, rank: 2 }), probability: 0.18717027757770679508, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.13042869926714159567, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.07258035093699109763, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.07150432736344392026, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.06478514777810424896, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.03729942559894651455, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.01940383876390557386, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.01680335584611366076, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.01505991459649522364, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.01260139956623134057, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.01255601071463844157, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.01162633849318523045, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.01004571676518003706, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.00925039518374657158, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Flanking, rank: 2 }), probability: 0.00800668011573009951, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00763220340745087919, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00516887250126509684, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.00487391389786530262, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Precise, rank: 3 }), probability: 0.00442768769196952728, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00412348123194863480, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00352044933904128348, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Flanking, rank: 2 }), probability: 0.00324416700477079753, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Precise, rank: 3 }), probability: 0.00311097319451295691, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00307333066142501934, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00253787117196495673, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00244392591888376292, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00199623438686989977, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00190525279406616337, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Precise, rank: 4 }), probability: 0.00186397148974680113, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Precise, rank: 4 }), probability: 0.00138175833693037148, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00094519514441591360, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00078828860460719401, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00064260504163894140, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00052578547754489259, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00043542703144557515, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00035795483183393540, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00025876377662147244, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00021367994576018592, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00019410778351728307, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00016725668389943048, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00007958215114410557, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00006637116498920683, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Equilibrium, rank: 3 }), probability: 0.00005823991984364850, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00005163844253386374, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00004794165824993689, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Flanking, rank: 3 }), probability: 0.00004526476862053626, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00004325597296498802, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00003926410449736546, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00003666144502905210, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Equilibrium, rank: 3 }), probability: 0.00003492944988107588, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00003146331958226327, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00003058173597888344, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00002302230475252594, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00001427942824337842, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00001365771322699597, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00000993355993760075, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.00000959654574899526, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000927060657523026, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00000918187214210722, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000765540964049620, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Flanking, rank: 2 }), probability: 0.00000738822183844307, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000657085474247307, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00000644287106871792, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00000609129476160287, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00000552084662631036, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000537528739446559, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Equilibrium, rank: 2 }), probability: 0.00000497495758611546, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Precise, rank: 3 }), probability: 0.00000412869039639155, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000285115182387662, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00000270723795801463, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Flanking, rank: 2 }), probability: 0.00000267378999595020, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000257487604469719, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Precise, rank: 3 }), probability: 0.00000245373979454563, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000237784811532842, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Precise, rank: 4 }), probability: 0.00000158532387568960, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000131345212912451, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00000115413244113088, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00000099771729948866, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Precise, rank: 4 }), probability: 0.00000098453839670160, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Blunted, rank: 5 }), probability: 0.00000047240387187415, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00000018903569783110, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00000018720559714202, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000011133501781692, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000009717394647340, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000009224885763393, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000008400433433888, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000006484863534150, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00000005733853200873, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Equilibrium, rank: 3 }), probability: 0.00000004750186632816, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Equilibrium, rank: 1 }), probability: 0.00000004749397826983, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000004483231193930, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Flanking, rank: 1 }), probability: 0.00000004087963816720, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 2 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000004036375965552, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Blunted, rank: 4 }), probability: 0.00000003977476667613, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Flanking, rank: 3 }), probability: 0.00000003860154345663, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 2 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000003702127905448, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Flanking, rank: 4 }), probability: 0.00000003464891254648, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Flanking, rank: 3 }), probability: 0.00000003464827162290, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Equilibrium, rank: 3 }), probability: 0.00000002720819426607, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Equilibrium, rank: 4 }), probability: 0.00000002280431557633, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000001378806520556, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000001149918590392, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 3 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000000661633667433, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000000635180611888, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 3 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000000588857867623, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000000348140469613, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000000300958327490, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Blunted, rank: 3 }), probability: 0.00000000142499162089, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Cautious, rank: 1 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000000044611207777, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 1 }, Perk { name: PerkName::Cautious, rank: 1 }), probability: 0.00000000012764595955, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 1 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000000010937884021, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Equilibrium, rank: 4 }), probability: 0.00000000003054285533, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Flanking, rank: 4 }), probability: 0.00000000002557570760, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Equilibrium, rank: 4 }), probability: 0.00000000001714890026, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000000001683594488, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000000001455423387, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Flanking, rank: 4 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000000000775642273, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Blunted, rank: 2 }), probability: 0.00000000000689120699, cost: 0 },
        //         Gizmo { perks: (Perk { name: PerkName::Equilibrium, rank: 4 }, Perk { name: PerkName::Precise, rank: 1 }), probability: 0.00000000000582487189, cost: 0 },
        //     ];
        //     let actual = calc_gizmo_probabilities(&*DATA, &budget, &input_materials, gizmo_type, is_ancient);
        //     assert_gizmo_vec_eq(&actual, &expected);
        // }

        #[test]
        fn ancient_weapon_120_9_historic() {
            let is_ancient = true;
            let gizmo_type = GizmoType::Weapon;
            let budget = Budget::create(120, is_ancient);
            let input_materials = vec![
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
                MaterialName::HistoricComponents,
            ];
            let expected = vec![
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.18904502521394730974, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.14997159790154498960, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.14392341568496988535, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.13660187150418456881, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 4 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.08349944985633553363, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Genocidal, rank: 1 }, Perk { name: PerkName::Looting, rank: 1 }), probability: 0.07420344522771468720, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.06725746099336796235, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 3 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.06441163335997490691, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.02762845193419527501, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 2 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.01373158504722604353, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Ultimatums, rank: 2 }), probability: 0.00761515973489005227, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 3 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.00539119868059511308, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Ultimatums, rank: 2 }), probability: 0.00532928688018971183, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Ultimatums, rank: 3 }), probability: 0.00483490553530691990, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Ultimatums, rank: 4 }), probability: 0.00463740981478982014, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Ultimatums, rank: 3 }), probability: 0.00456739924672708558, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Ultimatums, rank: 4 }), probability: 0.00430719885390781071, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Ultimatums, rank: 2 }), probability: 0.00364584717255837278, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Ultimatums, rank: 3 }), probability: 0.00268939525837567613, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Ultimatums, rank: 4 }), probability: 0.00228677022611015711, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 2 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00188776575592136025, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 4 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.00104133569079005624, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 4 }, Perk { name: PerkName::Precise, rank: 3 }), probability: 0.00052142505650557404, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 3 }, Perk { name: PerkName::Precise, rank: 3 }), probability: 0.00045951499144237449, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.00026917716634645907, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Ultimatums, rank: 2 }), probability: 0.00020068627335147074, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.00003837972421246555, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 4 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00000144756052569896, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 3 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00000114025080085868, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 2 }, Perk { name: PerkName::Genocidal, rank: 1 }), probability: 0.00000033991368080782, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Ultimatums, rank: 2 }, Perk { name: PerkName::Precise, rank: 2 }), probability: 0.00000027948935313978, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 5 }, Perk { name: PerkName::Ultimatums, rank: 1 }), probability: 0.00000000000000103234, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 6 }, Perk { name: PerkName::Ultimatums, rank: 1 }), probability: 0.00000000000000089645, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 4 }, Perk { name: PerkName::Ultimatums, rank: 1 }), probability: 0.00000000000000022292, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Precise, rank: 3 }, Perk { name: PerkName::Ultimatums, rank: 1 }), probability: 0.00000000000000000424, cost: 0 },
            ];
            let actual =
                calc_gizmo_probabilities(&*DATA, &budget, &input_materials, gizmo_type, is_ancient);
            assert_gizmo_vec_eq(&actual, &expected);
        }

        #[test]
        fn normal_armour_120_1_historic_1_tensile_2_plated() {
            let is_ancient = false;
            let gizmo_type = GizmoType::Armour;
            let budget = Budget::create(120, is_ancient);
            let input_materials = vec![
                MaterialName::HistoricComponents,
                MaterialName::TensileParts,
                MaterialName::PlatedParts,
                MaterialName::PlatedParts,
            ];
            let expected = vec![
                Gizmo { perks: (Perk { name: PerkName::Committed, rank: 1 }, Perk { name: PerkName::Mysterious, rank: 1 }), probability: 0.30937473912680502064, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Committed, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.29117622506052237563, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Mysterious, rank: 1 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.20577677602470972884, cost: 0 },
                Gizmo { perks: (Perk { name: PerkName::Empty, rank: 0 }, Perk { name: PerkName::Empty, rank: 0 }), probability: 0.19367225978796212549, cost: 0 },
            ];
            let actual =
                calc_gizmo_probabilities(&*DATA, &budget, &input_materials, gizmo_type, is_ancient);
            assert_gizmo_vec_eq(&actual, &expected);
        }
    }

    mod calc_wanted_gizmo_probabilities_test {
        use super::*;

        fn assert_resultlines_eq(actual: &Vec<ResultLine>, expected: &Vec<ResultLine>) {
            check_len(actual, expected);

            for (i, (acc, exp)) in actual.iter().zip(expected).enumerate() {
                check_index(acc.level, exp.level, i, "level", actual, expected);
                check_index_relative(acc.prob_attempt, exp.prob_attempt, 2.0, i, "prob_attempt" , actual, expected);
                check_index_relative(acc.prob_gizmo, exp.prob_gizmo, 2.0, i, "prob_gizmo" , actual, expected);
            }
        }

        #[test]
        fn ancient_armour_110_120_7_zamorak_2_sara() {
            let args = Args {
                ancient: true,
                gizmo_type: GizmoType::Armour,
                fuzzy: false,
                ..Default::default()
            };
            let budgets = generate_budgets(&InventionLevel::Range(110, 120), args.ancient);
            let input_materials = vec![
                MaterialName::ZamorakComponents,
                MaterialName::ZamorakComponents,
                MaterialName::ZamorakComponents,
                MaterialName::ZamorakComponents,
                MaterialName::ZamorakComponents,
                MaterialName::ZamorakComponents,
                MaterialName::ZamorakComponents,
                MaterialName::SaradominComponents,
                MaterialName::SaradominComponents,
            ];
            let wanted_gizmo = Gizmo { perks: (Perk { name: PerkName::Devoted, rank: 4 }, Perk { name: PerkName::Impatient, rank: 4 }), ..Default::default() };
            let expected = vec![
                ResultLine { level: 110, prob_gizmo: 0.00974262074653326794, prob_attempt: 0.00850963080954826069, ..Default::default() },
                ResultLine { level: 112, prob_gizmo: 0.01255816021290431274, prob_attempt: 0.01107308252145345825, ..Default::default() },
                ResultLine { level: 114, prob_gizmo: 0.01590000661605753610, prob_attempt: 0.01414257810865433666, ..Default::default() },
                ResultLine { level: 116, prob_gizmo: 0.01980789822146937149, prob_attempt: 0.01776096295684682566, ..Default::default() },
                ResultLine { level: 118, prob_gizmo: 0.02431630038465943874, prob_attempt: 0.02196620262677148952, ..Default::default() },
                ResultLine { level: 120, prob_gizmo: 0.02945385241280866484, prob_attempt: 0.02679068305588063956, ..Default::default() },
            ];
            let actual = calc_wanted_gizmo_probabilities(
                &*DATA,
                &args,
                &budgets,
                input_materials,
                wanted_gizmo,
                &mut None,
            );
            assert_resultlines_eq(&actual, &expected);
        }

        #[test]
        fn ancient_armour_110_120_1_harnessed_1_dextrous_7_variable() {
            let args = Args {
                ancient: true,
                gizmo_type: GizmoType::Armour,
                fuzzy: false,
                ..Default::default()
            };
            let budgets = generate_budgets(&InventionLevel::Range(110, 120), args.ancient);
            let input_materials = vec![
                MaterialName::HarnessedComponents,
                MaterialName::DextrousComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
            ];
            let wanted_gizmo = Gizmo { perks: (Perk { name: PerkName::TrophyTaker, rank: 5 }, Perk { name: PerkName::ClearHeaded, rank: 2 }), ..Default::default() };
            let expected = vec![
                ResultLine { level: 110, prob_gizmo: 0.01918158179611270664, prob_attempt: 0.01918158179611270664, ..Default::default() },
                ResultLine { level: 112, prob_gizmo: 0.02109631656835359720, prob_attempt: 0.02109631656835359720, ..Default::default() },
                ResultLine { level: 114, prob_gizmo: 0.02304803688981639856, prob_attempt: 0.02304803688981639856, ..Default::default() },
                ResultLine { level: 116, prob_gizmo: 0.02502587808462617899, prob_attempt: 0.02502587808462617899, ..Default::default() },
                ResultLine { level: 118, prob_gizmo: 0.02701942633140705374, prob_attempt: 0.02701942633140705374, ..Default::default() },
                ResultLine { level: 120, prob_gizmo: 0.02901884688250149988, prob_attempt: 0.02901884688250149988, ..Default::default() },
            ];
            let actual = calc_wanted_gizmo_probabilities(
                &*DATA,
                &args,
                &budgets,
                input_materials,
                wanted_gizmo,
                &mut None,
            );
            assert_resultlines_eq(&actual, &expected);
        }

        #[test]
        fn ancient_armour_50_60_1_harnessed_1_dextrous_7_variable() {
            let args = Args {
                ancient: true,
                gizmo_type: GizmoType::Armour,
                fuzzy: false,
                ..Default::default()
            };
            let budgets = generate_budgets(&InventionLevel::Range(50, 60), args.ancient);
            let input_materials = vec![
                MaterialName::HarnessedComponents,
                MaterialName::DextrousComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
            ];
            let wanted_gizmo = Gizmo { perks: (Perk { name: PerkName::TrophyTaker, rank: 5 }, Perk { name: PerkName::ClearHeaded, rank: 2 }), ..Default::default() };
            let expected = vec![
                ResultLine { level: 54, prob_gizmo: 0.00000000001215511520, prob_attempt: 0.00000000001215511520, ..Default::default() },
                ResultLine { level: 56, prob_gizmo: 0.00000000989853159803, prob_attempt: 0.00000000989853159803, ..Default::default() },
                ResultLine { level: 58, prob_gizmo: 0.00000017572813762414, prob_attempt: 0.00000017572813762414, ..Default::default() },
                ResultLine { level: 60, prob_gizmo: 0.00000112864757880545, prob_attempt: 0.00000112864757880545, ..Default::default() },
            ];
            let actual = calc_wanted_gizmo_probabilities(
                &*DATA,
                &args,
                &budgets,
                input_materials,
                wanted_gizmo,
                &mut None,
            );
            assert_resultlines_eq(&actual, &expected);
        }

        #[test]
        fn ancient_armour_50_60_1_harnessed_1_dextrous_7_variable_fuzzy() {
            let args = Args {
                ancient: true,
                gizmo_type: GizmoType::Armour,
                fuzzy: true,
                ..Default::default()
            };
            let budgets = generate_budgets(&InventionLevel::Range(50, 60), args.ancient);
            let input_materials = vec![
                MaterialName::HarnessedComponents,
                MaterialName::DextrousComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
                MaterialName::VariableComponents,
            ];
            let wanted_gizmo = Gizmo { perks: (Perk { name: PerkName::ClearHeaded, rank: 2 }, Perk { ..Default::default() }), ..Default::default() };
            let expected = vec![
                ResultLine { level: 50, prob_gizmo: 0.46018419656933490236, prob_attempt: 0.46018419656933490236, ..Default::default() },
                ResultLine { level: 52, prob_gizmo: 0.44214030724407260564, prob_attempt: 0.44214030724407260564, ..Default::default() },
                ResultLine { level: 54, prob_gizmo: 0.42436718836156678281, prob_attempt: 0.42436718836156678281, ..Default::default() },
                ResultLine { level: 56, prob_gizmo: 0.40708661016742259120, prob_attempt: 0.40708661016742259120, ..Default::default() },
                ResultLine { level: 58, prob_gizmo: 0.39049529671634181094, prob_attempt: 0.39049529671634181094, ..Default::default() },
                ResultLine { level: 60, prob_gizmo: 0.37476699430103094235, prob_attempt: 0.37476699430103094235, ..Default::default() },
            ];
            let actual = calc_wanted_gizmo_probabilities(
                &*DATA,
                &args,
                &budgets,
                input_materials,
                wanted_gizmo,
                &mut None,
            );
            assert_resultlines_eq(&actual, &expected);
        }
    }
}
